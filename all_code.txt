#include "push_swap.h"
#include <stdio.h>

void printall(x_stack *stack, char stack_name)
{
	printf("\n\n===== STACK %c =====\n", stack_name);
	while(stack)
	{
		printf("* Index: %d || value: %d\n",stack->index, stack->nbr);
		stack = stack->next;
	}
}
void print_help(void)
{
	printf("\n===== COMMAND DESCRIPTIONS =====\n");
	printf("sa  (swap a): Swap the first 2 elements at the top of stack a.\n");
	printf("sb  (swap b): Swap the first 2 elements at the top of stack b.\n");
	printf("ss          : Perform sa and sb at the same time.\n");
	printf("pa  (push a): Move the first element of b to the top of a.\n");
	printf("pb  (push b): Move the first element of a to the top of b.\n");
	printf("ra  (rotate a): Shift up all elements of stack a by 1 (first becomes last).\n");
	printf("rb  (rotate b): Shift up all elements of stack b by 1 (first becomes last).\n");
	printf("rr          : Perform ra and rb at the same time.\n");
	printf("rra (reverse rotate a): Shift down all elements of stack a by 1 (last becomes first).\n");
	printf("rrb (reverse rotate b): Shift down all elements of stack b by 1 (last becomes first).\n");
	printf("rrr         : Perform rra and rrb at the same time.\n");
	printf("================================\n");
}
void print_menu(void)
{
	printf("\n==== PUSH_SWAP MENU ====\n");
	printf("[ 0] Exit      [ 1] pa       [ 2] pb\n");
	printf("[ 3] sa        [ 4] sb       [ 5] ss\n");
	printf("[ 6] ra        [ 7] rb       [ 8] rr\n");
	printf("[ 9] rra       [10] rrb      [11] rrr\n");
	printf("[99] Help (show descriptions)\n");
	printf("========================\n>> ");
}



int main(int ac, char **av)
{
	if (ac > 1)
	{
		x_stack *a = NULL;
		x_stack *b = NULL;
		//int cont = 1;
		int op = 100;
		char **ar = split(av[1], ' ');
		init_a(&a, ar+1);
		sort_index(a);
		int total_n = stack_len(a);
		/*printall(a, 'a');
		printf("Total stack a = %d and b = %d", stack_len(a), stack_len(b));
		pb(&a, &b);
		add_index(a); add_index(b);
		printall(a, 'a'); printall(b, 'b');*/
		while(op != 0)
		{
			//if (op != 0)
			//	{printall(a, 'a'); printall(b, 'b');}
			if (is_sorted(a, total_n))
			{
			//	printf("All sorted");
				exit(1);
			}
			radix_sort(&a, &b);
			/*while (b)
			{
				calcular_todos_custos(a, b);
				x_stack *melhor = escolher_menor_custo(b);
				executar_movimento_ideal(&a, &b, melhor);
			}*/

			//sort_stack(&a, &b, total_n);
			/*print_menu();
			scanf(" %d", &op);
			switch (op)
			{
			case 0:
				op = 0;
				break;
			case 1:
				pa(&a, &b);
				break;
			case 2:
				pb(&a, &b);
				break;
			case 3:
				sa(&a);
				break;
			case 4:
				sb(&b);
				break;
			case 5:
				sa(&a);
				sb(&b);
				break;
			case 6:
				ra(&a);
				break;
			case 7:
				rb(&b);
				break;
			case 8:
				ra(&a);
				rb(&b);
				break;
			case 9:
				rra(&a);
				break;
			case 10:
				rrb(&b);
				break;
			case 11:
				rra(&a);
				rrb(&b);
				break;
			case 99:
				print_help();
				break;
			default:
				break;
			}*/

		}
	}
	return 0;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sorting.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pileonar <pileonar@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 16:58:06 by pileonar          #+#    #+#             */
/*   Updated: 2025/07/08 16:59:54 by pileonar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

static int	sort_init_index(x_stack *stack)
{
	x_stack	*tmp;
	int		ct;

	tmp = stack;
	ct = 0;
	while (tmp)
	{
		ct++;
		tmp->index = -1;
		tmp = tmp->next;
	}
	return (ct);
}

void	sort_index(x_stack *stack)
{
	x_stack	*tmp;
	x_stack	*min_node;
	int		i;
	int		ct;

	if (!stack)
		return ;
	i = 0;
	tmp = stack;
	ct = sort_init_index(stack);
	while (i <= ct)
	{
		tmp = stack;
		min_node = NULL;
		while (tmp)
		{
			if (tmp->index == -1 && (!min_node || tmp->nbr < min_node->nbr))
				min_node = tmp;
			tmp = tmp->next;
		}
		if (min_node)
			min_node->index = i;
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   operations_II.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pileonar <pileonar@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 16:27:38 by pileonar          #+#    #+#             */
/*   Updated: 2025/07/08 16:30:59 by pileonar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	pb(x_stack **a, x_stack **b)
{
	x_stack	*a_to_b;

	if (!(*a))
		return ;
	a_to_b = NULL;
	a_to_b = *a;
	*a = (*a)->next;
	if (*a)
		(*a)->prev = NULL;
	a_to_b->next = *b;
	if (*b)
		(*b)->prev = a_to_b;
	a_to_b->prev = NULL;
	*b = a_to_b;
	ft_putchar("pb");
}

void	pa(x_stack **a, x_stack **b)
{
	x_stack	*b_to_a;

	if (!(*b))
		return ;
	b_to_a = NULL;
	b_to_a = *b;
	*b = (*b)->next;
	if (*b)
		(*b)->prev = NULL;
	b_to_a->next = *a;
	if (*a)
		(*a)->prev = b_to_a;
	b_to_a->prev = NULL;
	*a = b_to_a;
	ft_putchar("pa");
}

void	sa(x_stack **a)
{
	if (!(*a) || !(*a)->next)
		return ;
	swap(&(*a)->nbr, &(*a)->next->nbr);
	swap(&(*a)->index, &(*a)->next->index);
	ft_putchar("sa");
}

void	sb(x_stack **b)
{
	if (!(*b) || !(*b)->next)
		return ;
	swap(&(*b)->nbr, &(*b)->next->nbr);
	swap(&(*b)->index, &(*b)->next->index);
	ft_putchar("sb");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   operations_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pileonar <pileonar@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 16:55:03 by pileonar          #+#    #+#             */
/*   Updated: 2025/07/08 16:57:29 by pileonar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

x_stack	*find_last(x_stack *stack)
{
	if (!stack)
		return (NULL);
	while (stack->next)
		stack = stack->next;
	return (stack);
}

int	stack_len(x_stack *stack)
{
	int	ct;

	if (!stack)
		return (0);
	ct = 0;
	while (stack)
	{
		stack = stack->next;
		ct++;
	}
	return (ct);
}

void	add_index(x_stack *stack)
{
	int	i;

	if (!stack)
		return ;
	i = 0;
	while (stack)
	{
		stack->index = i;
		i++;
		stack = stack->next;
	}
}

void	swap(int *a, int *b)
{
	int	tmp;

	tmp = *a;
	*a = *b;
	*b = tmp;
}
void ft_putchar(char *s)
{
	int	i;

	i = -1;
	while(s[++i])
		write(1, &s[i], 1);
	write(1, "\n", 1);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   operations_I.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pileonar <pileonar@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 16:24:21 by pileonar          #+#    #+#             */
/*   Updated: 2025/07/08 16:27:24 by pileonar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	ra(x_stack **a)
{
	x_stack	*tmp;
	x_stack	*last;

	if (!(*a) || !(*a)->next)
		return ;
	tmp = *a;
	*a = (*a)->next;
	(*a)->prev = NULL;
	last = find_last(*a);
	last->next = tmp;
	tmp->prev = last;
	tmp->next = NULL;
	ft_putchar("ra");
}

void	rb(x_stack **b)
{
	x_stack	*tmp;
	x_stack	*last;

	if (!(*b) || !(*b)->next)
		return ;
	tmp = *b;
	*b = (*b)->next;
	(*b)->prev = NULL;
	last = find_last(*b);
	last->next = tmp;
	tmp->prev = last;
	tmp->next = NULL;
	ft_putchar("rb");
}

void	rra(x_stack **a)
{
	x_stack	*last_to_first;
	x_stack	*new_last;

	if (!(*a) || !(*a)->next)
		return ;
	last_to_first = find_last(*a);
	new_last = last_to_first->prev;
	new_last->next = NULL;
	(*a)->prev = last_to_first;
	last_to_first->next = *a;
	*a = last_to_first;
	ft_putchar("rra");
}

void	rrb(x_stack **b)
{
	x_stack	*last_to_first;
	x_stack	*new_last;

	if (!(*b) || !(*b)->next)
		return ;
	last_to_first = find_last(*b);
	new_last = last_to_first->prev;
	new_last->next = NULL;
	(*b)->prev = last_to_first;
	last_to_first->next = *b;
	*b = last_to_first;
	ft_putchar("rrb");
}
#ifndef PUSH_SWAP_H
#define PUSH_SWAP_H

# include <stdlib.h>
# include <stdbool.h> //To use bool flags, e.g, to print or not to print
# include <limits.h> //To define MIN and MAX macros	

#include <unistd.h>
#include <stdio.h> //-> remember to delete!

/*typedef struct s_stack
{
	int	nbr;
	int	index;
	struct s_stack	*next;
	struct s_stack	*prev;
} x_stack;*/
typedef struct s_stack {
	int nbr;
	int index;
	struct s_stack *next;
	struct s_stack *prev;
} x_stack;


char	**split(char *s, char d);
void init_a(x_stack **a, char **av);
x_stack *find_last(x_stack *stack);
void add_index(x_stack *stack);
long ft_atol(char *s);

void pa(x_stack **a, x_stack **b);
void pb(x_stack **a, x_stack **b);
void sa(x_stack **a);
void sb(x_stack **b);
void ra(x_stack **a);
void rb(x_stack **b);
void rra(x_stack **a);
void rrb(x_stack **b);

void radix_sort(x_stack **a, x_stack **b);
void sort_index(x_stack *stack);
x_stack *find_last(x_stack *stack);
int stack_len(x_stack *stack);
void swap(int *a, int *b);
int is_sorted(x_stack *a, int tot);

char	**create_array(int ac, char **array_nb);
//int	count_words(char *s, char d);
//void	sort_stack(x_stack **stack_a, x_stack **stack_b, int tot);
//void	simple_sort(x_stack **stack_a, x_stack **stack_b, int tot);
//void	sort_5(x_stack **stack_a, x_stack **stack_b, int tot);
//static void	sort_4(x_stack **stack_a, x_stack **stack_b, int tot);
//static void	sort_3(x_stack **stack_a, int tot);
//static int	get_min(x_stack **stack, int val);
char *join_all(char *s1, char *s2);
char	*ft_strdup(char *src);
int check_digit(char *s);
void ft_putchar(char *s);
int check_limit(long n);

# endifNAME = push_swap
CC = cc 
CFLAGS = -Wall -Wextra -Werror -g # <- delete
DEPS = push_swap.h
SRCS = main.c cli_to_stack/cli_to_stack.c operations/operations_I.c operations/operations_II.c operations/operations_utils.c cli_to_stack/split.c algorithm/algo_radix.c operations/sorting.c \
cli_to_stack/cli_to_stack_utils.c cli_to_stack/check_errors.c
OBJS = $(SRCS:.c=.o)

all: $(NAME)

$(NAME): $(OBJS)
	$(CC) $(CFLAGS) $(SRCS) -o $(NAME)

clean: 
	rm -f $(OBJS)

fclean: clean
	rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re 

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   algo_radix.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pileonar <pileonar@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 16:17:06 by pileonar          #+#    #+#             */
/*   Updated: 2025/07/08 16:17:54 by pileonar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

void	radix_sort(x_stack **a, x_stack **b)
{
	int	max_bits;
	int	max_index;
	int	i;
	int	j;

	i = 0;
	max_bits = 0;
	max_index = stack_len(*a) - 1;
	while (max_index >> max_bits)
		max_bits++;
	while (i < max_bits)
	{
		j = 0;
		while (j < (max_index + 1))
		{
			if ((((*a)->index >> i) & 1) == 0)
				pb(a, b);
			else
				ra(a);
			j++;
		}
		while (*b)
			pa(a, b);
		i++;
	}
}

int	is_sorted(x_stack *a, int tot)
{
	int		ct;
	x_stack	*tmp;

	ct = stack_len(a);
	if (ct < tot)
		return (0);
	tmp = a;
	while (tmp->next)
	{
		if (tmp->index > tmp->next->index)
			return (0);
		tmp = tmp->next;
	}
	return (1);
}
#include "../push_swap.h"

static int slen(char *s)
{
	int	ct;

	ct = 0;
	while(s[ct])
		ct++;
	return (ct);
}
char	*ft_strdup(char *src)
{
	char	*new;
	int		i;

	i = 0;
	new = (char *)malloc(sizeof(char) * slen(src) + 1);
	if (!new)
		return (NULL);
	while (*src)
		new[i++] = *src++;
	new[i] = '\0';
	return (new);
}


char *join_all(char *s1, char *s2)
{
	int		i;
	//int		len;
	char	*new;

	i = 0;
	//if (!s1)
	//	return (NULL);
	if (s1 && !s2)
		return (ft_strdup(s1));
	new = malloc(sizeof(char) * (slen(s1) + slen(s2) + 2));
	if (!new)
		return (NULL);
	while (*s1)
		new[i++] = *s1++;
	new[i++] = ' ';
	while (*s2)
		new[i++] = *s2++;
	new[i] = '\0';
	return (new);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   split.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pileonar <pileonar@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 16:23:42 by pileonar          #+#    #+#             */
/*   Updated: 2025/07/08 17:35:34 by pileonar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

/*static int	count_words(char *s, char d)
{
	int		ct;
	bool	within;
	int		i;

	i = 0;
	ct = 0;
	while (s[i])
	{
		within = false;
		while (s[i] && s[i] == d)
			i++;
		while (s[i] && s[i] != d)
		{
			if (!within)
			{
				ct += 1;
				within = true;
			}
			i++;
		}
	}
	return (ct);
}

static char	*get_wd(char *s, char d)
{
	static int	cursor; //= 0 not necessary
	int			len;
	int			i;
	char		*word;

	i = 0;
	len = 0;
	while (s[cursor] == d)
		cursor++;
	while (s[cursor + len] != d && s[cursor + len])
		len++;
	word = malloc(sizeof(char) * (len + 1));
	if (!word)
		return (NULL);
	while (s[cursor] != d && s[cursor])
		word[i++] = s[cursor++];
	word[i] = '\0';
	return (word);
}

char	**split(char *s, char d)
{
	int		len_tokens;
	char	**array;
	int		i;

	i = 0;
	array = NULL;
	len_tokens = count_words(s, d);
	if (!len_tokens)
		exit(1);
	array = malloc(sizeof(char *) * (len_tokens + 1));
	if (!array)
		return (NULL);
	while (i < len_tokens)//(len_tokens-- >= 0)
	{
		array[i++] = get_wd(s, d);
	}
	array[i] = NULL;
	return (array);
}*/

#include "../push_swap.h"

static void	free_split(char **array)
{
	int	i;

	if (!array)
		return ;
	i = 0;
	while (array[i])
	{
		free(array[i]);
		i++;
	}
	free(array);
}

static int	count_words(char *s, char d)
{
	int	i;
	int	ct;
	int	in_word;

	i = 0;
	ct = 0;
	in_word = 0;
	while (s[i])
	{
		if (s[i] != d && !in_word)
		{
			in_word = 1;
			ct++;
		}
		else if (s[i] == d)
			in_word = 0;
		i++;
	}
	return (ct);
}

static char	*get_word(char *s, char d, int *i)
{
	int		start;
	int		end;
	char	*word;

	while (s[*i] && s[*i] == d)
		(*i)++;
	start = *i;
	while (s[*i] && s[*i] != d)
		(*i)++;
	end = *i;
	word = malloc(sizeof(char) * (end - start + 1));
	if (!word)
		return (NULL);
	*i = start;
	end = 0;
	while (s[*i] && s[*i] != d)
		word[end++] = s[(*i)++];
	word[end] = '\0';
	return (word);
}

char	**split(char *s, char d)
{
	int		i;
	int		k;
	int		words;
	char	**array;

	i = 0;
	k = 0;
	words = count_words(s, d);
	array = malloc(sizeof(char *) * (words + 1));
	if (!array)
		return (NULL);
	while (k < words)
	{
		array[k] = get_word(s, d, &i);
		if (!array[k])
		{
			free_split(array);
			return (NULL);
		}
		k++;
	}
	array[k] = NULL;
	return (array);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cli_to_stack.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pileonar <pileonar@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 16:19:44 by pileonar          #+#    #+#             */
/*   Updated: 2025/07/08 18:01:02 by pileonar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

long	ft_atol(char *s)
{
	int		i;
	int		sg;
	long	r;

	i = 0;
	r = 0;
	sg = 1;
	while (s[i] == ' ' || (s[i] >= 7 && s[i] <= 13))
		i++;
	if (s[i] == '+' || s[i] == '-')
	{
		if (s[i] == '-')
			sg = -1;
		i++;
	}
	while (s[i] >= '0' && s[i] <= '9')
		r = (r * 10) + (s[i++] - '0');
	return (r * sg);
}

static void	append_node(x_stack **stack, int n)
{
	x_stack	*node;
	x_stack	*last;

	node = malloc(sizeof(x_stack));
	if (!node)
		return ;
	node->nbr = n;
	node->next = NULL;
	if (!(*stack))
	{
		*stack = node;
		node->prev = NULL;
	}
	else
	{
		last = find_last(*stack);
		last->next = node;
		node->prev = last;
	}
}
static void	free_stack(x_stack *stack_a)
{
	x_stack *tmp;
	while (stack_a)
	{
		tmp = stack_a;
		stack_a = stack_a->next;
		free(tmp);
	}
	exit(0);
}

void	init_a(x_stack **a, char **av)
{
	int		i;
	long	n;

	i = 0;
	while (av[i])
	{
		n = ft_atol(av[i]);
		if (!check_limit(n))
			{
				ft_putchar("Error");
				free_stack(*a);
				return ;
			}
		append_node(a, (int)n);
		i++;
	}
}



/*char	**create_array(int ac, char **array_nb)
{
	char	**ar;
	char	*joined_args;
	char	*temp;
	int		i;

	ar = NULL;
	if (ac == 2)
		ar = split(array_nb[1], ' ');
	if (ac > 2) //usar o strjoin ate o fim de modo que a string possa ser passada a split
		{
			i = 3;
			joined_args = join_all(array_nb[1], array_nb[2]);
			if (!joined_args)
				return (NULL);
			while(i < (ac - 1))
			{
				temp = join_all(joined_args, array_nb[i]);
				if (!temp)
					return (NULL);
				free (joined_args);
				joined_args = temp;
				i++;
			}
			ar = split(joined_args, ' ');
		}
	//implementar verificador de erros
		return (ar);
}*/

/* //versao 2
char	**create_array(int ac, char **array_nb)
{
	char	**ar;
	char	*joined_args;
	char	*temp;
	int		i;

	ar = NULL;
	if (ac == 2)
		{
			if (!check_digit(array_nb[1]))
				return (0);
			return (split(array_nb[1], ' '));
		}
	else if (ac > 2)
	{
		joined_args = ft_strdup(array_nb[1]);
		if (!joined_args)
			return (NULL);
		i = 2;
		while (i < ac)
		{
			temp = join_all(joined_args, array_nb[i]); // une com espaÃ§o
			if (!temp)
				return (NULL);
			free(joined_args);
			joined_args = temp;
			i++;
		}
		if (!check_digit(joined_args))
			{free(joined_args); return (NULL);}
		ar = split(joined_args, ' ');
		free(joined_args);
	}
	return (ar);
}
*/

#include "../push_swap.h"

char	**create_array(int ac, char **av)
{
	char	**ar;
	char	*joined;
	char	*temp;
	int		i;

	ar = NULL;
	if (ac == 2)
	{
		if (!check_digit(av[1]))
			return (NULL);
		ar = split(av[1], ' ');
	}
	else if (ac > 2)
	{
		joined = ft_strdup(av[1]);
		if (!joined)
			return (NULL);
		i = 2;
		while (i < ac)
		{
			temp = join_all(joined, av[i]);
			if (!temp)
			{
				free(joined);
				return (NULL);
			}
			free(joined);
			joined = temp;
			i++;
		}
		if (!check_digit(joined))
		{
			free(joined);
			return (NULL);
		}
		ar = split(joined, ' ');
		free(joined);
	}
	return (ar);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_errors.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pileonar <pileonar@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 18:02:10 by pileonar          #+#    #+#             */
/*   Updated: 2025/07/08 18:22:16 by pileonar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../push_swap.h"

// enquanto ainda sao strings: check_digit

int check_digit(char *s)
{
	int	i;

	i = 0;
	while (s[i])
	{
		if (!(s[i] >= '0' && s[i] <= '9') && s[i] != ' ')
		{
			ft_putchar("Error");
			return (0);
		}
		i++;
	}
	return (1);
}

//durante a conversao: check_limit
int check_limit(long n)
{
	if ((n > INT_MAX) || (n < INT_MIN))
		return (0);
	return (1);
}

//ja em linkedlist: check_duplicates/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pileonar <pileonar@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/08 17:05:27 by pileonar          #+#    #+#             */
/*   Updated: 2025/07/08 17:54:36 by pileonar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

/*static void	free_exit(char **arr, x_stack *stack_a, x_stack *stack_b)
{
	x_stack *tmp;
	int		i;

	i = 0;
	//if (!arr)
	//	return;
	while (arr[i])
		free(arr[i++]);
	free(arr);
	while (stack_a)
	{
		tmp = stack_a;
		stack_a = stack_a->next;
		free(tmp);
	}
	while (stack_b)
	{
		tmp = stack_b;
		stack_b = stack_b->next;
		free(tmp);
	}
	exit(0);
}*/
/*static void free_split(char **array) {
    int i = 0;
    if (!array) return;
    while (array[i])
        free(array[i++]);
    free(array);
}*/

static void	free_exit(char **arr, x_stack *stack_a, x_stack *stack_b)
{
	x_stack *tmp;
	int		i;

	i = 0;
	if (arr)
	{
		while (arr[i])
		{
			free(arr[i]);
			i++;
		}
		free(arr);
	}
	while (stack_a)
	{
		tmp = stack_a;
		stack_a = stack_a->next;
		free(tmp);
	}
	while (stack_b)
	{
		tmp = stack_b;
		stack_b = stack_b->next;
		free(tmp);
	}
	exit(0);
}

int main(int ac, char **av)
{
	if (ac > 1)
	{
		x_stack	*a;
		x_stack	*b;
		char	**parsed_array;
		int		total_n;

		a = NULL;
		b = NULL;
		//ar = split(av[1], ' ');
		parsed_array = create_array(ac, av);
		if (!parsed_array)
			free_exit(parsed_array, a, b); //exit(1);
		init_a(&a, parsed_array);
		if (!a)
			free_exit(parsed_array, a, b);
		total_n = stack_len(a);
		sort_index(a);
		while (1)
		{
			if (is_sorted(a, total_n))
				free_exit(parsed_array, a, b);//exit(1);
			radix_sort(&a, &b);
		}
	}

	return (0);
}